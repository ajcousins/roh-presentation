# ROH Presentation

## Technical Challenges Encountered on a New Digital Product

### Light Lookup Introduction
A full stack web application which queries a database of technical lighting products, intended for lighting designers and specifiers of technical lighting equipment, as a way to find suitable products to meet very specific design requirements.

The app is exciting for me, as a person with several years of lighting design experience, I believe it can be the perfect tool to help plug a designer's gap in market knowledge. There is currently no go-to search engine that lighting designers can consult that focuses exclusively on architectural products. A few search tools currently catalogue decorative products, but are not able to filter down to technical specifications.

![Dashboard](https://github.com/ajcousins/roh-presentation/blob/main/dashboard_01.png "Dashboard")

[Live website](https://light-lookup.pages.dev/#/) |
[Code repo](https://github.com/ajcousins/light-lookup)

### Bulk Upload (Server side)
- A technical challenge I had was the ability to upload multiple products to the database.
- It is possible to upload single products one at a time to the database using the website form. The intention is for manufacturers to be able to upload one-off products to an already established catalogue. However, for adding a large new catalogue to the database, this would be impractical and slow. 
- To achieve this, I created a new API endpoint `/populate` on the server, which accepts a csv file upload.

```js
// adminRouter.js
const express = require("express");
const multer = require("multer");
const upload = multer({ dest: "./" });

const adminController =  require("./../controllers/adminController");
const router  =  express.Router();

router.post("/populate", upload.single("file"), adminController.populate);

module.exports = router;
```
```js
//parseCsv.js
const csv = require("csv-parser");
const fs = require("fs");
const sanitise = require("./sanitise");

const parseCsv = (file) => {
  return new Promise((resolve, reject) => {
    const results = [];
    fs.createReadStream(file)
      .pipe(csv({}))
      .on("data", (product) => results.push(product))
      .on("end", () => {
        fs.unlinkSync(file);
        resolve(sanitise(results));
      });
  });
};

module.exports = parseCsv;
```

- The csv file is parsed through the above function and csv-parser module. This turns the csv file into an array of objects. Each document is sent through a `sanitise` function which checks whether every property is valid, and formats any nested lists correctly.

- Going forward, the UI for accessing this functionality still needs to be built, as it's only available through an API POST request. The route will also need to check if a particular user is authorised to carry out the request.

- Another issue will be persisting the link with user comments and reviews- if an entire catalogue of products needs to be updated. At the moment the product IDs are generated by MongoDB. But for links with reviews and comments to persist, will make more sense if the IDs were assigned programmatically.


### Interactive UI (Client side)
- I wanted the dashboard to be visual and fun for the user, bearing in mind the app is primarily targeted at designers. I wanted any changes to the form to be reflected in real-time, or have some kind of effect on a visual aspect of the form.
- This lead me to learn about inline svgs in React and their ability to dynamically render. For product beam angles, this involved hooking up a slider's (from MaterialUI/ React component library) controlled input to state, and then plugging this value directly into the "svg component", which accepts the value as a prop. 
- The component itself has a function which calculates the correct angle for each of the masks, creating the desired effect.

### Other Technical Challenges
- Incorporating Three.js into the UI as a way for the user to interactively see their constraints change in real-time.

<!--INSERT IMAGE-->

## Design and Development
- The project was built with React and TypeScript on the front end, with Redux used for state management. Material UI was used for its React component library- mainly for the dashboard and form elements. I also used SASS with BEM class naming for organisation. The back end was built with Node.js, Express with a GraphQL endpoint which queries a MongoDB database. Firebase firestore was also used for image storage.
- The use of Redux made sense to me on the front-end, as a way to manage state globally, especially for several form elements and the search dashboard itself. The user query made to the server is quite long and complex- so it made sense to break up the components into parts that could discretely manage each slice of the state in Redux.
- TypeScript was a new language for me and I intended to learn as I built. But looking back, the use of TypeScript I believe was a good design decision. A good example are the props for React elements containing product information. The 'product' prop could be typechecked against a 'product' type and ensured no fields were missing when passing this through multiple components.
- When planning Light Lookup, the app had a long list of features I wanted to implement. However I quickly realised it would be several months before I would be able to deploy anything useable.
- To overcome this, I have planned to structure the delivery in several phases which make sense to me. Version 1 is the minimum viable product, which is able to perform complex queries, add a basic manufacturer profile and add single products. The aim was to release this version as quickly as possible in around a 3 week timeframe for some initial feedback from a few lighting designers.

![Planning](https://github.com/ajcousins/roh-presentation/blob/main/planning_01.png "Project Planning")



## Resilience and Scalability
- I opted to use GraphQL with scalability in mind for Light Lookup, mainly for its ability to be selective with what data it returns, as opposed to a RestAPI, which will 'over-fetch' data. The ‘Product’ database model already has quite a lot of fields, and a lot of this data is not relevant for a basic search.
- I am also expecting that products will link to other parts of the database, for example compatible lamps/ bulbs, which will then have their own fields and criteria which will need to be fetched separately. This also plays to GraphQL’s strengths: it's ability to link to other models from a single root query.
- In practice, when a user queries the database using the app, there will be multiple server requests for smaller chunks of data:
  1. First query returns the number of objects in the list. This is mainly to help set up the pagination navigation for the UI.
  1. The app queries again for just the first page of objects, which returns more technical information about each product. 
  1. Subsequently, there can be further/ optional queries which are carried out when the user expands the product tile, giving more in-depth information: metrics/ supplier information, compatible equipment etc. 
- This method makes sense to me, bearing scalability in mind, allowing more detailed technical information to be retrieved per page load or on product tile expand.
- Another issue related to scalability was the upload of user images for products and manufacturer logos. I used Firebase to store my images, and needed to ensure the space was not taken up by huge images. On a past project, image resizing was done on the server before being forwarded to AWS S3. However, in this case the image wasn't being passed to my back-end, so it made sense to resize the image on the client-side first before uploading to Firebase.
- Image resizing was a bit of a challenge for me, as it involved passing an image buffer to state and then formatting this before it is uploaded to Firebase. Using TypeScript on the frontend helped a lot in this situation and helped flagged bugs by typechecking.

## Working in a Test Environment and Moving to Deployment
- Light Lookup has not gone through any thorough any test environments as my knowledge in this area is limited. 
- I have used a suite of tests using Jest for the back-end and the built-in test suites in React for the front-end.
- I intended to practise TDD on Light Lookup, but quickly realised it would be very time consuming to do this for every single component- so unit testing was focused to a few specific areas I felt might be at risk. 
- My intuition also told me it was better to manually test for visual UI elements in the web browser. An automated test wouldn’t necessarily let me know if a navigation element overflowed for example.
- Several unit tests were carried out on the data collection helper functions on the backend as I expect the data would eventually come from a variety of different manufacturers in all shapes and sizes or through web scraping. 

![Upload Check](https://github.com/ajcousins/roh-presentation/blob/main/unit-test_01.png "Upload Check")

- Unit tests were also written for a few formatting elements in react on the client side.

![Format Check](https://github.com/ajcousins/roh-presentation/blob/main/unit-test_02.png "Format Check")
![Format Check](https://github.com/ajcousins/roh-presentation/blob/main/unit-test_03.png "Format Check")

- Site is deployed using Cloudflare, which is linked to the GitHub repository, allowing any updates to the main branch to be automatically deployed.




